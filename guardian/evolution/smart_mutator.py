"""
Smart Mutation Generation Engine for Python Code.

This module provides the `SmartMutator` class, a context-aware mutation
generation engine. It aims to create high-value mutants by analyzing Python
source code using Abstract Syntax Trees (AST) and predefined fault patterns.
Key components include:
- `MutantType`: Enum for different categories of mutations.
- `Mutant`: Dataclass representing a generated mutant with scoring.
- `FaultPattern`: Dataclass for regex-based fault pattern definitions.
- `MutationOperatorVisitor`: An AST visitor to identify and generate
  AST-based mutation candidates.
- `SmartMutator`: The main class orchestrating mutant generation, scoring,
  and prioritization.
"""

import ast
import random
import logging
from typing import List, Dict, Any, Set, Optional
from dataclasses import dataclass
from enum import Enum
import re
import os
import pathlib
import copy
from concurrent.futures import ProcessPoolExecutor, as_completed

logger = logging.getLogger(__name__)


class MutantType(Enum):
    """Enumeration of supported mutation types."""
    ARITHMETIC = "arithmetic"
    RELATIONAL = "relational"
    LOGICAL = "logical"
    ASSIGNMENT = "assignment"
    STATEMENT = "statement"
    BOUNDARY = "boundary"
    NULL_CHECK = "null_check"
    EXCEPTION = "exception"


@dataclass
class Mutant:
    """
    Represents a single generated mutant.

    Attributes:
        original_code (str): The original code snippet that was mutated.
        mutated_code (str): The code snippet after mutation.
        mutation_type (MutantType): The type of mutation applied.
        line_number (int): The line number in the original file where the
                           mutation occurs.
        impact_score (float): A score representing the potential impact of
                              this mutant (e.g., based on code complexity).
        likelihood (float): A score representing the likelihood of this
                            mutation pattern corresponding to a real fault.
        description (str): A human-readable description of the mutation.
        id (str): A unique identifier for the mutant, generated in __post_init__.
    """
    original_code: str
    mutated_code: str
    mutation_type: MutantType
    line_number: int
    impact_score: float
    likelihood: float
    description: str
    
    def __post_init__(self):
        """Generates a unique ID for the mutant based on its content."""
        self.id = f"mutant_{hash(self.original_code + self.mutated_code)}"


@dataclass
class FaultPattern:
    """
    Defines a regex-based fault pattern for generating mutants.

    Attributes:
        name (str): A descriptive name for the fault pattern.
        pattern_regex (str): The regular expression to find code matching
                             this pattern.
        mutation_rules (List[Dict[str, str]]): A list of rules defining how
                                              to transform the matched code.
                                              Each rule is a dict, typically
                                              with 'from', 'to', 'type', and
                                              'description'.
        impact_weight (float): A base weight for the impact of mutants
                               generated by this pattern.
        description (str): A human-readable description of the fault pattern.
    """
    name: str
    pattern_regex: str
    mutation_rules: List[Dict[str, str]]
    impact_weight: float
    description: str

# Helper function for parallel processing, defined at module level for pickling
def _process_single_file_for_mutants(
    file_path_str: str, 
    original_file_content: str, 
    target_mutation_types: Optional[List[MutantType]]
) -> List[Dict[str, Any]]:
    """
    Processes a single Python source file to generate raw mutant data.

    This function is designed to be executed in a separate process by a
    `ProcessPoolExecutor`. It parses the given file content, uses the
    `MutationOperatorVisitor` to find mutation opportunities, and returns
    a list of dictionaries, each representing a potential mutant.

    Args:
        file_path_str (str): The path to the source file being processed.
        original_file_content (str): The string content of the source file.
        target_mutation_types (Optional[List[MutantType]]): A list of
            `MutantType` enums to filter the types of mutants generated.
            If None or empty, all applicable types are generated.

    Returns:
        List[Dict[str, Any]]: A list of dictionaries, where each dictionary
        contains raw data for a generated mutant (e.g., line number,
        operator info, code snippets, mutation type). Returns an empty
        list if errors occur during processing.
    """
    # Note: Logger might not work as expected in separate processes unless configured.
    # For simplicity, critical errors might be better raised and caught in the main process.
    local_logger = logging.getLogger(__name__ + "._process_single_file")
    try:
        tree = ast.parse(original_file_content, filename=file_path_str)
        # MutationOperatorVisitor needs to be defined or imported here if it's not global
        # For this structure, it will be globally available in the same module.
        visitor = MutationOperatorVisitor(
            file_path=file_path_str,
            original_file_content=original_file_content,
            target_mutation_types=target_mutation_types
        )
        visitor.visit(tree)
        return visitor.mutants
    except SyntaxError as e:
        local_logger.warning(f"Syntax error parsing {file_path_str} in worker: {e}")
        return []
    except Exception as e:
        local_logger.error(f"Error processing file {file_path_str} in worker: {e}")
        return []

class MutationOperatorVisitor(ast.NodeTransformer):
    """
    An AST NodeTransformer that identifies and collects potential mutation points.

    This visitor traverses an Abstract Syntax Tree (AST) of Python code.
    For various AST node types (e.g., binary operations, comparisons, constants),
    it generates dictionaries representing potential mutants. These dictionaries
    contain details like line numbers, original and mutated operator types,
    code snippets, and the type of mutation.

    The visitor can be configured to target only specific `MutantType`s.
    The generated mutants are stored as dictionaries in the `self.mutants` list.
    """
    def __init__(self, file_path: str, original_file_content: str, target_mutation_types: Optional[List[MutantType]] = None):
        """
        Initializes the MutationOperatorVisitor.

        Args:
            file_path (str): Path to the source file being visited.
            original_file_content (str): The full content of the source file.
            target_mutation_types (Optional[List[MutantType]]): An optional
                list of `MutantType` enums. If provided, only mutants of these
                types will be generated. If None or empty, all applicable
                mutation types supported by the visitor are generated.
        """
        self.file_path = file_path
        self.original_file_content = original_file_content
        self.mutants: List[Dict[str, Any]] = []
        if target_mutation_types:
            self.target_mutation_values: Optional[Set[str]] = {mt.value for mt in target_mutation_types}
        else:
            self.target_mutation_values = None # Apply all if None or empty
        # Define mappings for operator replacements
        self.binary_op_map = {
            ast.Add: ast.Sub, ast.Sub: ast.Add,
            ast.Mult: ast.Div, ast.Div: ast.Mult,
            ast.FloorDiv: ast.Mult, # Simplified, consider alternatives like ast.Div
            ast.Mod: ast.Mult,      # Simplified, consider alternatives
            ast.Pow: ast.Mult,      # Simplified
            ast.LShift: ast.RShift, ast.RShift: ast.LShift,
            ast.BitOr: ast.BitAnd, ast.BitAnd: ast.BitOr,
            ast.BitXor: ast.BitOr,  # Simplified
        }
        self.comparison_op_map = {
            ast.Eq: ast.NotEq, ast.NotEq: ast.Eq,
            ast.Lt: ast.Gt, ast.Gt: ast.Lt,
            ast.LtE: ast.GtE, ast.GtE: ast.LtE,
            ast.Is: ast.IsNot, ast.IsNot: ast.Is,
            ast.In: ast.NotIn, ast.NotIn: ast.In,
        }
        self.exception_type_map = {
            "ValueError": "TypeError",
            "TypeError": "ValueError",
            "KeyError": "IndexError",
            "IndexError": "KeyError",
            "IOError": "OSError",
            "OSError": "IOError",
            "ZeroDivisionError": "ArithmeticError", # Broaden slightly
            "AttributeError": "NameError",
            "NameError": "AttributeError",
            "LookupError": "KeyError", # Example of narrowing
            "Exception": "BaseException", # Broaden to the very base
            # Specific to general
            "FileNotFoundError": "IOError",
            "ConnectionError": "OSError",
            # General to specific (less common but possible for mutation)
            # "RuntimeError": "NotImplementedError", # Example
        }
        
    def visit_BinOp(self, node: ast.BinOp) -> ast.AST:
        """
        Visits an `ast.BinOp` node to generate ARITHMETIC mutants.

        Replaces binary operators (e.g., +, -, *, /) with their counterparts
        as defined in `self.binary_op_map`. For example, `a + b` might
        become `a - b`.

        Mutants are added to `self.mutants` if `MutantType.ARITHMETIC` is
        targeted or if no specific types are targeted.

        Args:
            node (ast.BinOp): The binary operation AST node.

        Returns:
            ast.AST: The original node.
        """
        original_op_type = type(node.op)
        current_mutation_type_value = MutantType.ARITHMETIC.value
        
        if (self.target_mutation_values is None or current_mutation_type_value in self.target_mutation_values) and \
           original_op_type in self.binary_op_map:
            mutated_op_type = self.binary_op_map[original_op_type]
            
            mutated_node = copy.deepcopy(node)
            mutated_node.op = mutated_op_type()

            original_snippet: Optional[str] = None
            try:
                original_snippet = ast.get_source_segment(self.original_file_content, node)
            except Exception:
                logger.warning(
                    f"Could not get original source segment for BinOp at "
                    f"{self.file_path}:{node.lineno}"
                )
            
            mutated_snippet: Optional[str] = None
            try:
                mutated_snippet = ast.unparse(mutated_node)
            except Exception as e:
                logger.warning(
                    f"Could not unparse mutated BinOp at "
                    f"{self.file_path}:{node.lineno}: {e}"
                )

            if mutated_snippet is not None:
                self.mutants.append({
                    "file_path": str(self.file_path),
                    "line_number": node.lineno,
                    "original_operator": original_op_type.__name__,
                    "mutated_operator": mutated_op_type.__name__,
                    "original_code_snippet": original_snippet,
                    "mutated_code_snippet": mutated_snippet,
                    "mutation_type": current_mutation_type_value
                })
        super().generic_visit(node) # Ensure we visit children nodes
        return node

    def visit_Compare(self, node: ast.Compare) -> ast.AST:
        """
        Visits an `ast.Compare` node to generate RELATIONAL mutants.

        Replaces comparison operators (e.g., ==, <, >) with their counterparts
        as defined in `self.comparison_op_map`. For example, `a == b` might
        become `a != b`. Handles chained comparisons by mutating one operator
        at a time.

        Mutants are added to `self.mutants` if `MutantType.RELATIONAL` is
        targeted or if no specific types are targeted.

        Args:
            node (ast.Compare): The comparison AST node.

        Returns:
            ast.AST: The original node.
        """
        for i, op_node in enumerate(node.ops):
            original_op_type = type(op_node)
            current_mutation_type_value = MutantType.RELATIONAL.value

            if (self.target_mutation_values is None or current_mutation_type_value in self.target_mutation_values) and \
               original_op_type in self.comparison_op_map:
                mutated_op_type = self.comparison_op_map[original_op_type]

                mutated_node = copy.deepcopy(node)
                mutated_node.ops[i] = mutated_op_type()

                original_snippet: Optional[str] = None
                try:
                    original_snippet = ast.get_source_segment(self.original_file_content, node)
                except Exception:
                    logger.warning(
                        f"Could not get original source segment for Compare op at "
                        f"{self.file_path}:{node.lineno}"
                    )
                
                mutated_snippet: Optional[str] = None
                try:
                    mutated_snippet = ast.unparse(mutated_node)
                except Exception as e:
                    logger.warning(
                        f"Could not unparse mutated Compare op at "
                        f"{self.file_path}:{node.lineno}: {e}"
                    )
                
                if mutated_snippet is not None:
                    self.mutants.append({
                        "file_path": str(self.file_path),
                        "line_number": node.lineno,
                        "original_operator": original_op_type.__name__,
                        "mutated_operator": mutated_op_type.__name__,
                        "original_code_snippet": original_snippet,
                        "mutated_code_snippet": mutated_snippet,
                        "mutation_type": current_mutation_type_value
                    })
        super().generic_visit(node) # Ensure we visit children nodes
        return node

    def visit_Assign(self, node: ast.Assign) -> ast.AST:
        """
        Visits an `ast.Assign` node to generate ASSIGNMENT mutants for constants.

        If the right-hand side of an assignment is a constant (numeric, boolean,
        string, or None), this method generates mutants by changing that
        constant to other plausible values (e.g., 0, +/-1 for numbers;
        toggling booleans; empty string, "mutated_string", or None for strings).

        Mutants are added to `self.mutants` if `MutantType.ASSIGNMENT` is
        targeted or if no specific types are targeted. This method calls
        `super().generic_visit(node)` to allow `visit_Constant` to also
        process the constant on the RHS if it's a standalone constant node.

        Args:
            node (ast.Assign): The assignment AST node.

        Returns:
            ast.AST: The original node.
        """
        current_mutation_type_value = MutantType.ASSIGNMENT.value
        if (self.target_mutation_values is None or current_mutation_type_value in self.target_mutation_values) and \
           isinstance(node.value, ast.Constant):
            original_value = node.value.value
            potential_new_values: List[Any] = []

            if isinstance(original_value, (int, float)) and not isinstance(original_value, bool):
                potential_new_values.extend([
                    0,
                    original_value + 1,
                    original_value - 1,
                    -original_value
                ])
                if original_value != 0: # Avoid duplicate 0
                    pass
            elif isinstance(original_value, bool):
                potential_new_values.append(not original_value)
            elif isinstance(original_value, str):
                potential_new_values.extend(["", "mutated_string"])
                if original_value == "": # Avoid "" -> ""
                    potential_new_values.remove("")
                if original_value == "mutated_string": # Avoid "mutated_string" -> "mutated_string"
                    potential_new_values.remove("mutated_string")


            # Mutate to None if not already None
            if original_value is not None:
                potential_new_values.append(None)
            else: # Original value is None
                potential_new_values.extend([0, ""])


            # Remove duplicates and the original value itself if present
            unique_new_values = []
            for val in potential_new_values:
                if val not in unique_new_values and val != original_value:
                    unique_new_values.append(val)
            
            for new_value in unique_new_values:
                mutated_node = copy.deepcopy(node)
                mutated_node.value = ast.Constant(value=new_value)

                original_snippet: Optional[str] = None
                try:
                    # Get source for the whole assignment statement
                    original_snippet = ast.get_source_segment(self.original_file_content, node)
                except Exception:
                    logger.warning(
                        f"Could not get original source segment for Assign at "
                        f"{self.file_path}:{node.lineno}"
                    )
                
                mutated_snippet: Optional[str] = None
                try:
                    mutated_snippet = ast.unparse(mutated_node)
                except Exception as e:
                    logger.warning(
                        f"Could not unparse mutated Assign at "
                        f"{self.file_path}:{node.lineno}: {e}"
                    )

                if mutated_snippet is not None:
                    self.mutants.append({
                        "file_path": str(self.file_path),
                        "line_number": node.lineno,
                        "original_operator": f"Assign(value={type(original_value).__name__})", # More descriptive
                        "mutated_operator": f"Assign(value={type(new_value).__name__})",   # More descriptive
                        "original_code_snippet": original_snippet,
                        "mutated_code_snippet": mutated_snippet,
                        "mutation_type": current_mutation_type_value
                    })
        
        # Always call generic_visit to ensure all parts of the node are visited
        # including targets and the value (RHS).
        # visit_Constant will handle the Constant on RHS if present.
        # Tests or downstream processing will need to handle potential overlaps if necessary.
        super().generic_visit(node)
        return node

    def visit_BoolOp(self, node: ast.BoolOp) -> ast.AST:
        """
        Visits an `ast.BoolOp` node (e.g., `and`, `or`) to generate LOGICAL mutants.

        Replaces boolean operators with their alternatives (e.g., `and` becomes
        `or`, `or` becomes `and`).

        Mutants are added to `self.mutants` if `MutantType.LOGICAL` is
        targeted or if no specific types are targeted.

        Args:
            node (ast.BoolOp): The boolean operation AST node.

        Returns:
            ast.AST: The original node.
        """
        original_op_type = type(node.op)
        mutated_op_type: Optional[type[ast.boolop]] = None
        current_mutation_type_value = MutantType.LOGICAL.value

        if not (self.target_mutation_values is None or current_mutation_type_value in self.target_mutation_values):
            super().generic_visit(node)
            return node

        if isinstance(node.op, ast.And):
            mutated_op_type = ast.Or
        elif isinstance(node.op, ast.Or):
            mutated_op_type = ast.And

        if mutated_op_type: # This implies the check for target_mutation_values passed or was None
            mutated_node = copy.deepcopy(node)
            mutated_node.op = mutated_op_type()

            original_snippet: Optional[str] = None
            try:
                original_snippet = ast.get_source_segment(self.original_file_content, node)
            except Exception:
                logger.warning(
                    f"Could not get original source segment for BoolOp at "
                    f"{self.file_path}:{node.lineno}"
                )
            
            mutated_snippet: Optional[str] = None
            try:
                mutated_snippet = ast.unparse(mutated_node)
            except Exception as e:
                logger.warning(
                    f"Could not unparse mutated BoolOp at "
                    f"{self.file_path}:{node.lineno}: {e}"
                )

            if mutated_snippet is not None:
                self.mutants.append({
                    "file_path": str(self.file_path),
                    "line_number": node.lineno,
                    "original_operator": original_op_type.__name__,
                    "mutated_operator": mutated_op_type.__name__,
                    "original_code_snippet": original_snippet,
                    "mutated_code_snippet": mutated_snippet,
                    "mutation_type": current_mutation_type_value
                })
        
        super().generic_visit(node) # Ensure we visit children nodes
        return node

    def visit_If(self, node: ast.If) -> ast.AST:
        """
        Visits an `ast.If` node to generate LOGICAL mutants by negating its test condition.

        For example, `if x > 10:` becomes `if not (x > 10):`, and
        `if not is_valid:` becomes `if is_valid:`. The generated mutant
        focuses on the condition itself.

        Mutants are added to `self.mutants` if `MutantType.LOGICAL` is
        targeted or if no specific types are targeted.

        Args:
            node (ast.If): The if statement AST node.

        Returns:
            ast.AST: The original node.
        """
        current_mutation_type_value = MutantType.LOGICAL.value # Negating an If condition is a logical mutation
        if not (self.target_mutation_values is None or current_mutation_type_value in self.target_mutation_values):
            super().generic_visit(node) # Still visit children even if this specific mutation is skipped
            return node

        # Mutate by negating the test condition
        mutated_node = copy.deepcopy(node)
        
        # If the condition is already a `not something`, unwrap it.
        # Otherwise, wrap it with `not`.
        if isinstance(node.test, ast.UnaryOp) and isinstance(node.test.op, ast.Not):
            mutated_node.test = node.test.operand # Unwrap not
        else:
            mutated_node.test = ast.UnaryOp(op=ast.Not(), operand=copy.deepcopy(node.test))

        original_snippet: Optional[str] = None
        try:
            # Get source for the test condition itself.
            original_snippet = ast.get_source_segment(self.original_file_content, node.test)
        except Exception:
            logger.warning(
                f"Could not get original source segment for If condition at "
                f"{self.file_path}:{node.lineno}"
            )
        
        mutated_condition_snippet: Optional[str] = None
        try:
            mutated_condition_snippet = ast.unparse(mutated_node.test)
        except Exception as e:
            logger.warning(
                f"Could not unparse mutated If condition at "
                f"{self.file_path}:{node.lineno}: {e}"
            )

        if mutated_condition_snippet is not None: # Check if the condition snippet itself was unparsed
            self.mutants.append({
                "file_path": str(self.file_path),
                "line_number": node.lineno, # Line number of the 'if' keyword
                "original_operator": "IfCondition", 
                "mutated_operator": "IfConditionNot", 
                "original_code_snippet": original_snippet, 
                "mutated_code_snippet": mutated_condition_snippet, 
                "mutation_type": current_mutation_type_value
            })
        
        super().generic_visit(node)
        return node

    def visit_Try(self, node: ast.Try) -> ast.AST:
        """
        Visits an `ast.Try` node to generate EXCEPTION mutants.

        One type of mutation generated is to "unwrap" the try block,
        meaning the statements in the `try` body are kept, but the
        `try...except...else...finally` structure is removed. This simulates
        the absence of exception handling.

        Mutants are added to `self.mutants` if `MutantType.EXCEPTION` is
        targeted or if no specific types are targeted.

        Args:
            node (ast.Try): The try statement AST node.

        Returns:
            ast.AST: The original node.
        """
        current_mutation_type_value = MutantType.EXCEPTION.value
        if not (self.target_mutation_values is None or current_mutation_type_value in self.target_mutation_values):
            super().generic_visit(node)
            return node

        # Mutation: Remove exception handling (effectively run only the 'try' body)
        # This is a conceptual mutation; the mutated code is the body of the try block.
        
        original_snippet: Optional[str] = None
        try:
            original_snippet = ast.get_source_segment(self.original_file_content, node)
        except Exception:
            logger.warning(
                f"Could not get original source segment for Try block at "
                f"{self.file_path}:{node.lineno}"
            )

        mutated_body_snippet_parts = []
        for stmt in node.body:
            try:
                mutated_body_snippet_parts.append(ast.unparse(stmt))
            except Exception as e:
                logger.warning(
                    f"Could not unparse statement in Try body at "
                    f"{self.file_path}:{stmt.lineno}: {e}"
                )
        mutated_body_snippet = "\n".join(mutated_body_snippet_parts) if mutated_body_snippet_parts else None

        if original_snippet and mutated_body_snippet:
            self.mutants.append({
                "file_path": str(self.file_path),
                "line_number": node.lineno,
                "original_operator": "TryExceptBlock",
                "mutated_operator": "UnwrappedTryBody",
                "original_code_snippet": original_snippet,
                "mutated_code_snippet": mutated_body_snippet,
                "mutation_type": current_mutation_type_value,
                "description": "Remove try-except block, leaving only the try body's statements."
            })
        
        # Continue visiting children (handlers, orelse, finalbody)
        super().generic_visit(node)
        return node

    def visit_ExceptHandler(self, node: ast.ExceptHandler) -> ast.AST:
        """
        Visits an `ast.ExceptHandler` node to generate EXCEPTION mutants.

        Generates mutants by:
        1. Changing the type of the caught exception to another related type
           (e.g., `KeyError` to `IndexError`) based on `self.exception_type_map`.
        2. Changing a specific exception handler to a bare `except:`.

        Mutants are added to `self.mutants` if `MutantType.EXCEPTION` is
        targeted or if no specific types are targeted.

        Args:
            node (ast.ExceptHandler): The except handler AST node.

        Returns:
            ast.AST: The original node.
        """
        current_mutation_type_value = MutantType.EXCEPTION.value
        if not (self.target_mutation_values is None or current_mutation_type_value in self.target_mutation_values):
            super().generic_visit(node) # Still visit children of the handler
            return node

        if node.type: # If None, it's a bare except, which we won't change type for here
            original_exc_type_node = node.type
            original_exc_name: Optional[str] = None
            try:
                original_exc_name = ast.unparse(original_exc_type_node)
            except Exception:
                 logger.warning(
                    f"Could not unparse original exception type at "
                    f"{self.file_path}:{node.lineno}"
                )
            
            if original_exc_name and original_exc_name in self.exception_type_map:
                new_exc_name_str = self.exception_type_map[original_exc_name]
                
                mutated_handler_node = copy.deepcopy(node)
                # The new type needs to be an AST node, typically ast.Name for simple exceptions
                # For tuple exceptions `except (A, B):`, node.type would be ast.Tuple
                # This simple map currently assumes single name exceptions.
                try:
                    # Attempt to parse the new exception name as an expression,
                    # then ensure it's a valid type for an except handler (e.g., ast.Name or ast.Attribute)
                    new_type_node_candidate = ast.parse(new_exc_name_str).body[0]
                    if isinstance(new_type_node_candidate, ast.Expr):
                         mutated_handler_node.type = new_type_node_candidate.value
                    else:
                        # Fallback or log error if parsing doesn't yield a simple expression
                        logger.warning(f"Could not form valid AST type node for '{new_exc_name_str}' at {self.file_path}:{node.lineno}")
                        super().generic_visit(node)
                        return node

                except SyntaxError:
                    logger.warning(f"Syntax error parsing new exception type '{new_exc_name_str}' at {self.file_path}:{node.lineno}")
                    super().generic_visit(node)
                    return node


                original_snippet: Optional[str] = None
                try:
                    original_snippet = ast.get_source_segment(self.original_file_content, node)
                except Exception:
                    logger.warning(
                        f"Could not get original source segment for ExceptHandler at "
                        f"{self.file_path}:{node.lineno}"
                    )
                
                mutated_snippet: Optional[str] = None
                try:
                    mutated_snippet = ast.unparse(mutated_handler_node)
                except Exception as e:
                    logger.warning(
                        f"Could not unparse mutated ExceptHandler at "
                        f"{self.file_path}:{node.lineno}: {e}"
                    )

                if original_snippet and mutated_snippet:
                    self.mutants.append({
                        "file_path": str(self.file_path),
                        "line_number": node.lineno,
                        "original_operator": f"Catch({original_exc_name})",
                        "mutated_operator": f"Catch({new_exc_name_str})",
                        "original_code_snippet": original_snippet,
                        "mutated_code_snippet": mutated_snippet,
                        "mutation_type": current_mutation_type_value,
                        "description": f"Change caught exception type from {original_exc_name} to {new_exc_name_str}"
                    })
            
            # Also consider mutating to a bare except if it's not already one
            if node.type is not None: # if it has a type, we can make it bare
                mutated_bare_handler = copy.deepcopy(node)
                mutated_bare_handler.type = None # Make it a bare except

                original_snippet_for_bare: Optional[str] = None
                try:
                    original_snippet_for_bare = ast.get_source_segment(self.original_file_content, node)
                except Exception:
                    pass # Already logged above potentially
                
                mutated_snippet_for_bare: Optional[str] = None
                try:
                    mutated_snippet_for_bare = ast.unparse(mutated_bare_handler)
                except Exception as e:
                     logger.warning(
                        f"Could not unparse bare mutated ExceptHandler at "
                        f"{self.file_path}:{node.lineno}: {e}"
                    )
                
                if original_snippet_for_bare and mutated_snippet_for_bare:
                    self.mutants.append({
                        "file_path": str(self.file_path),
                        "line_number": node.lineno,
                        "original_operator": f"Catch({original_exc_name or 'SpecificException'})",
                        "mutated_operator": "Catch(BareException)",
                        "original_code_snippet": original_snippet_for_bare,
                        "mutated_code_snippet": mutated_snippet_for_bare,
                        "mutation_type": current_mutation_type_value,
                        "description": f"Change specific exception handler to bare except"
                    })


        super().generic_visit(node) # Visit children of the handler (e.g., its body)
        return node

    def visit_Constant(self, node: ast.Constant) -> ast.AST:
        """
        Visits an `ast.Constant` node to generate various types of mutants.

        Depending on the type of the constant value:
        - Numeric (int, float): Generates BOUNDARY mutants (e.g., val+1, val-1, 0, -val)
                               and an ASSIGNMENT mutant (val to None).
        - Boolean: Generates LOGICAL mutants (e.g., True to False) and an
                   ASSIGNMENT mutant (val to None).
        - String: Generates ASSIGNMENT mutants (e.g., to empty string,
                  "mutated_string", or None).
        - None: Generates ASSIGNMENT mutants (e.g., None to 0 or empty string).

        The specific `MutantType` (BOUNDARY, LOGICAL, ASSIGNMENT) is determined
        by the nature of the mutation. Mutants are added to `self.mutants` if
        their respective type is targeted or if no specific types are targeted.

        Args:
            node (ast.Constant): The constant AST node.

        Returns:
            ast.AST: The original node.
        """
        original_value = node.value
        potential_new_values_map: Dict[str, List[Any]] = {
            MutantType.BOUNDARY.value: [],
            MutantType.LOGICAL.value: [],
            MutantType.ASSIGNMENT.value: []
        }
        current_mutation_type_value = "" # Will be set based on original_value type

        if isinstance(original_value, (int, float)) and not isinstance(original_value, bool):
            current_mutation_type_value = MutantType.BOUNDARY.value
            mutations = [
                original_value + 1,
                original_value - 1,
                0
            ]
            if original_value != 0: # Avoid -0 if value is 0, and 0-1 = -1
                mutations.append(-original_value)
            potential_new_values_map[current_mutation_type_value].extend(mutations)

        elif isinstance(original_value, bool):
            current_mutation_type_value = MutantType.LOGICAL.value
            potential_new_values_map[current_mutation_type_value].append(not original_value)

        elif isinstance(original_value, str):
            current_mutation_type_value = MutantType.ASSIGNMENT.value
            str_muts = ["", "mutated_string"]
            if original_value == "": str_muts.remove("")
            if original_value == "mutated_string": str_muts.remove("mutated_string")
            potential_new_values_map[current_mutation_type_value].extend(str_muts)
        
        elif original_value is None:
            current_mutation_type_value = MutantType.ASSIGNMENT.value # For None -> 0 or ""
            potential_new_values_map[current_mutation_type_value].extend([0, ""])


        # Mutate to None if not already None (ASSIGNMENT type)
        if original_value is not None:
            # This adds a None mutation for all types (numeric, bool, str)
            # and classifies it as ASSIGNMENT.
            # Check if ASSIGNMENT type is targeted if we are to add this.
            if self.target_mutation_values is None or MutantType.ASSIGNMENT.value in self.target_mutation_values:
                # Avoid adding None if it's already in the list for the primary mutation type
                # (e.g. if primary type was ASSIGNMENT and None was already added)
                already_present = False
                if current_mutation_type_value == MutantType.ASSIGNMENT.value:
                    if None in potential_new_values_map[MutantType.ASSIGNMENT.value]:
                        already_present = True
                
                if not already_present and None != original_value:
                     potential_new_values_map[MutantType.ASSIGNMENT.value].append(None)


        for mut_type_val, new_values_list in potential_new_values_map.items():
            if not new_values_list:
                continue

            if not (self.target_mutation_values is None or mut_type_val in self.target_mutation_values):
                continue

            # Remove duplicates and the original value itself if present
            unique_new_values = []
            for val in new_values_list:
                if val not in unique_new_values and val != original_value:
                    unique_new_values.append(val)

            for new_value in unique_new_values:
                mutated_constant_node = ast.Constant(value=new_value)
                
                original_snippet: Optional[str] = None
                try:
                    original_snippet = ast.unparse(node)
                except Exception:
                    logger.warning(
                        f"Could not unparse original Constant at "
                        f"{self.file_path}:{node.lineno}"
                    )

                mutated_snippet: Optional[str] = None
                try:
                    mutated_snippet = ast.unparse(mutated_constant_node)
                except Exception as e:
                    logger.warning(
                        f"Could not unparse mutated Constant at "
                        f"{self.file_path}:{node.lineno}: {e}"
                    )

                if original_snippet is not None and mutated_snippet is not None:
                    description = f"Change constant {original_snippet} to {mutated_snippet}"
                    if mut_type_val == MutantType.BOUNDARY.value:
                        if new_value == original_value + 1: description = f"Increment constant {original_value} to {new_value}"
                        elif new_value == original_value - 1: description = f"Decrement constant {original_value} to {new_value}"
                        elif new_value == 0: description = f"Change constant {original_value} to 0"
                        elif new_value == -original_value: description = f"Negate constant {original_value} to {new_value}"
                    elif mut_type_val == MutantType.LOGICAL.value:
                        description = f"Change boolean constant {original_value} to {new_value}"
                    elif mut_type_val == MutantType.ASSIGNMENT.value:
                        if new_value == "": description = f"Change string constant '{original_value}' to empty string"
                        elif new_value == "mutated_string": description = f"Change string constant '{original_value}' to 'mutated_string'"
                        elif new_value is None: description = f"Change constant {original_value} to None"
                        elif original_value is None and isinstance(new_value, str) : description = f"Change constant None to empty string"
                        elif original_value is None and isinstance(new_value, int) : description = f"Change constant None to 0"


                    self.mutants.append({
                        "file_path": str(self.file_path),
                        "line_number": node.lineno,
                        "original_operator": f"Constant({type(original_value).__name__})",
                        "mutated_operator": f"Constant({type(new_value).__name__})",
                        "original_code_snippet": original_snippet,
                        "mutated_code_snippet": mutated_snippet,
                        "mutation_type": mut_type_val,
                        "description": description
                    })
        
        super().generic_visit(node) # Though ast.Constant has no children to visit
        return node

class SmartMutator:
    """
    Orchestrates the generation of context-aware, high-value mutants for Python code.

    This class combines AST-based mutation (via `MutationOperatorVisitor`) and
    regex-based fault pattern matching to produce a diverse set of mutants.
    It includes logic for scoring mutants based on factors like code complexity
    and predefined pattern weights, and then prioritizes them according to a
    mutation budget.

    Attributes:
        codebase_path (str): The root path of the codebase to be mutated.
                             (Currently used by `_get_source_files` placeholder).
        mutation_budget (int): The maximum number of mutants to return after
                               prioritization.
        fault_patterns (List[FaultPattern]): A list of predefined regex-based
                                            fault patterns.
        complexity_cache (Dict[Any, Any]): A cache for storing complexity scores
                                           (currently not fully utilized beyond
                                           function-level complexity in
                                           `_generate_file_mutants`).
        bug_history (List[Any]): Placeholder for incorporating historical bug data
                                 (currently unused).
    """
    
    def __init__(self, codebase_path: str, mutation_budget: int = 100):
        """
        Initializes the SmartMutator.

        Args:
            codebase_path (str): The root path of the Python codebase.
                                 This is used by `_get_source_files` if no
                                 specific target file is provided to
                                 `generate_smart_mutants`.
            mutation_budget (int): The maximum number of mutants to generate
                                   after prioritization. Defaults to 100.
        """
        self.codebase_path = codebase_path
        self.mutation_budget = mutation_budget
        
        self.fault_patterns = self._initialize_fault_patterns()
        
        self.complexity_cache = {}
        self.bug_history = []
        
    def generate_smart_mutants(self, target_file: Optional[str] = None) -> List[Mutant]:
        """
        Generates and prioritizes a list of `Mutant` objects.

        This is the primary public method for generating mutants. It processes
        either a specific target file or all source files found in the
        `codebase_path`. For each file, it calls `_generate_file_mutants`
        to get a list of `Mutant` objects. All collected mutants are then
        prioritized using `_prioritize_mutants`, and the top N mutants
        up to `self.mutation_budget` are returned.

        Args:
            target_file (Optional[str]): The path to a specific Python file
                to mutate. If None, all Python files found via
                `_get_source_files` (based on `self.codebase_path`)
                will be processed. Defaults to None.

        Returns:
            List[Mutant]: A list of `Mutant` objects, prioritized by score,
                          and limited by `self.mutation_budget`.
        """
        logger.info(f"Generating smart mutants with budget {self.mutation_budget}")
        all_mutants_data = [] # Temporarily store dicts
        
        target_files = [target_file] if target_file else self._get_source_files()
        
        for file_path_str in target_files:
            try:
                with open(file_path_str, 'r', encoding='utf-8') as f:
                    source_code = f.read()
                
                # This part uses the old _generate_file_mutants which returns List[Mutant]
                # For consistency, if generate_mutants_for_project is the main API,
                # this method might need to adapt or be deprecated.
                # For now, let's assume it's still used and returns List[Mutant]
                file_mutant_objects = self._generate_file_mutants(source_code, file_path_str)
                all_mutants_data.extend(file_mutant_objects) # Assuming these are Mutant objects
                
            except Exception as e:
                logger.warning(f"Error processing file {file_path_str} for smart_mutants: {e}")
        
        # Prioritize and limit mutants
        # _prioritize_mutants expects List[Mutant]
        prioritized_mutants = self._prioritize_mutants(all_mutants_data)
        return prioritized_mutants[:self.mutation_budget]
    
    def _generate_file_mutants(self, source_code: str, file_path: str) -> List[Mutant]:
        """
        Generates a list of `Mutant` objects for a single source code file.

        This method performs the core mutant generation for a given file:
        1. Parses the source code into an AST.
        2. Uses `MutationOperatorVisitor` to generate raw AST-based mutant data
           (dictionaries).
        3. Calculates cyclomatic complexity for functions within the file to
           inform scoring.
        4. Converts the raw AST mutant data into `Mutant` objects, applying
           specific scoring logic (e.g., for `if` condition negations in
           complex functions).
        5. Applies regex-based fault patterns using `_apply_fault_patterns`
           to generate additional `Mutant` objects.
        
        All generated `Mutant` objects are returned in a single list.

        Args:
            source_code (str): The string content of the Python source file.
            file_path (str): The path to the source file (used for context and
                             logging).

        Returns:
            List[Mutant]: A list of `Mutant` objects generated from the file.
                          Returns an empty list if critical errors occur.
        """
        mutants_list_of_mutant_objects: List[Mutant] = []
        
        try:
            tree = ast.parse(source_code, filename=file_path)
            
            # 1. Generate raw AST-based mutant data using MutationOperatorVisitor
            #    No target_mutation_types filter here, as we want all applicable AST mutants.
            visitor = MutationOperatorVisitor(
                file_path=file_path,
                original_file_content=source_code,
                target_mutation_types=None # Get all types the visitor supports
            )
            visitor.visit(tree)
            raw_ast_mutants_data: List[Dict[str, Any]] = visitor.mutants

            # Prepare complexity map for scoring (extracted from _generate_complexity_weighted_mutants)
            # This map will store func_node.lineno -> complexity_score
            complexity_map: Dict[int, float] = {}
            func_definitions: Dict[int, ast.FunctionDef] = {}

            for node in ast.walk(tree):
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    complexity = self._calculate_cyclomatic_complexity(node)
                    # Store complexity if > 5, also store the function node itself
                    # to check if a mutant's line number falls within this function.
                    if complexity > 5: # Threshold for "complex"
                        complexity_map[node.lineno] = complexity
                        func_definitions[node.lineno] = node


            # 2. Convert raw AST mutant data to Mutant objects and apply scoring
            for mut_dict in raw_ast_mutants_data:
                # Determine if this mutant is part of a complex function for special scoring
                mutant_line = mut_dict["line_number"]
                is_in_complex_func = False
                base_complexity_score = 0.0

                for func_start_line, func_node in func_definitions.items():
                    func_end_line = func_node.end_lineno if hasattr(func_node, 'end_lineno') and func_node.end_lineno is not None else mutant_line # fallback
                    if func_start_line <= mutant_line <= func_end_line:
                        is_in_complex_func = True
                        base_complexity_score = complexity_map.get(func_start_line, 0.0)
                        break
                
                # Default scoring
                impact = 1.0
                likelihood = 0.5
                description = mut_dict.get("description", "AST-based mutation")

                # Apply complexity-based scoring for if-negations in complex functions
                if mut_dict["mutation_type"] == MutantType.LOGICAL.value and \
                   mut_dict["original_operator"] == "IfCondition" and \
                   is_in_complex_func and base_complexity_score > 0:
                    impact = base_complexity_score / 10.0 # As per _mutate_complex_node
                    likelihood = 0.7 # As per _mutate_complex_node
                    description = "Negate if condition in complex function"
                
                # TODO: Add more sophisticated scoring based on mutant type, context, etc.

                original_code_snippet = mut_dict.get("original_code_snippet", "N/A")
                mutated_code_snippet = mut_dict.get("mutated_code_snippet", "N/A")

                # Ensure snippets are not None before creating Mutant object
                if original_code_snippet is None: original_code_snippet = "Error: Original snippet unavailable"
                if mutated_code_snippet is None: mutated_code_snippet = "Error: Mutated snippet unavailable"


                try:
                    mutant_type_enum = MutantType(mut_dict["mutation_type"])
                except ValueError:
                    logger.warning(f"Unknown mutation type '{mut_dict['mutation_type']}' for mutant at {file_path}:{mut_dict['line_number']}. Skipping.")
                    continue

                mutant = Mutant(
                    original_code=original_code_snippet,
                    mutated_code=mutated_code_snippet,
                    mutation_type=mutant_type_enum,
                    line_number=mut_dict["line_number"],
                    impact_score=impact,
                    likelihood=likelihood,
                    description=description
                )
                mutants_list_of_mutant_objects.append(mutant)

            # 3. Apply regex-based fault patterns (these are already Mutant objects)
            #    The 'lines' variable is not available anymore, _apply_fault_patterns might need source_code only
            #    or we re-split. For now, let's assume it can work with source_code.
            #    If it strictly needs lines, we can split source_code here.
            lines = source_code.split('\n')
            pattern_mutants = self._apply_fault_patterns(source_code, lines)
            mutants_list_of_mutant_objects.extend(pattern_mutants)
            
            # The calls to _generate_boundary_mutants and _generate_exception_mutants are now
            # covered by the MutationOperatorVisitor (visit_Compare, visit_Constant, visit_Try, visit_ExceptHandler).
            # The _generate_complexity_weighted_mutants logic for *scoring* is partially integrated above.

        except SyntaxError as e:
            logger.warning(f"Syntax error in {file_path} during _generate_file_mutants: {e}")
        except Exception as e:
            logger.error(f"Error generating mutants for {file_path} in _generate_file_mutants: {e}", exc_info=True)
        
        return mutants_list_of_mutant_objects
    
    def _apply_fault_patterns(self, source_code: str, lines: List[str]) -> List[Mutant]:
        """
        Applies predefined regex-based fault patterns to the source code.

        Iterates through `self.fault_patterns`. For each pattern, it searches
        the `source_code` using the pattern's regex. For each match, it applies
        the pattern's mutation rules to generate `Mutant` objects.

        Args:
            source_code (str): The full source code of the file as a string.
            lines (List[str]): The source code split into a list of lines
                               (used for determining line numbers, though
                               line numbers are now calculated from `source_code`
                               and `match.start()`).

        Returns:
            List[Mutant]: A list of `Mutant` objects generated from the
                          applied fault patterns.
        """
        mutants = []
        
        for pattern in self.fault_patterns:
            try:
                matches = re.finditer(pattern.pattern_regex, source_code, re.MULTILINE)
                
                for match in matches:
                    line_num = source_code[:match.start()].count('\n') + 1
                    
                    for rule in pattern.mutation_rules:
                        original = match.group(0)
                        mutated = re.sub(rule['from'], rule['to'], original)
                        
                        if mutated != original:
                            mutant = Mutant(
                                original_code=original,
                                mutated_code=mutated,
                                mutation_type=MutantType(rule.get('type', 'statement')),
                                line_number=line_num,
                                impact_score=pattern.impact_weight,
                                likelihood=self._calculate_likelihood(original, pattern),
                                description=f"{pattern.name}: {rule.get('description', 'Pattern mutation')}"
                            )
                            mutants.append(mutant)
                            
            except Exception as e:
                logger.warning(f"Error applying pattern {pattern.name}: {e}")
        
        return mutants
    
    # _generate_complexity_weighted_mutants is removed as its logic is integrated into _generate_file_mutants
    
    # _generate_boundary_mutants and its helpers (_create_boundary_mutations, _create_numeric_mutations)
    # are removed as their functionality is covered by MutationOperatorVisitor (visit_Compare, visit_Constant)

    # _generate_exception_mutants and its helpers (_create_exception_removal_mutant, _create_exception_type_mutations)
    # are removed as their functionality is covered by MutationOperatorVisitor (visit_Try, visit_ExceptHandler)

    def _prioritize_mutants(self, mutants: List[Mutant]) -> List[Mutant]:
        """
        Sorts a list of mutants based on their priority score.

        The priority score for each mutant is calculated as
        `mutant.impact_score * mutant.likelihood`. Mutants are sorted in
        descending order of this score.

        Args:
            mutants (List[Mutant]): A list of `Mutant` objects to be prioritized.

        Returns:
            List[Mutant]: The list of mutants, sorted by priority score in
                          descending order.
        """
        for mutant in mutants:
            # Ensure priority_score attribute exists or handle if not
            if not hasattr(mutant, 'priority_score'):
                 mutant.priority_score = 0.0 # Default if not set
            mutant.priority_score = mutant.impact_score * mutant.likelihood
        
        return sorted(mutants, key=lambda m: m.priority_score, reverse=True)
    
    def _initialize_fault_patterns(self) -> List[FaultPattern]:
        """
        Initializes and returns a list of predefined `FaultPattern` objects.

        These patterns are used by `_apply_fault_patterns` for regex-based
        mutation generation. Each pattern defines a regex, rules for mutation,
        and an impact weight.

        Returns:
            List[FaultPattern]: A list of configured `FaultPattern` objects.
        """
        return [
            FaultPattern(
                name="Off-by-one errors",
                pattern_regex=r'for\s+\w+\s+in\s+range\([^)]+\)',
                mutation_rules=[
                    {'from': r'range\((\w+)\)', 'to': r'range(\1 - 1)', 'type': 'boundary', 'description': 'Reduce range by 1'},
                    {'from': r'range\((\w+)\)', 'to': r'range(\1 + 1)', 'type': 'boundary', 'description': 'Increase range by 1'},
                ],
                impact_weight=2.0,
                description="Common off-by-one boundary errors"
            ),
            FaultPattern(
                name="Null pointer dereference",
                pattern_regex=r'(\w+)\.(\w+)\(',
                mutation_rules=[
                    {'from': r'(\w+)\.(\w+)\(', 'to': r'None.\2(', 'type': 'null_check', 'description': 'Replace object with None'},
                ],
                impact_weight=3.0,
                description="Null pointer access patterns"
            ),
            FaultPattern(
                name="Boolean NOT removal", # Renamed for clarity
                pattern_regex=r'\bnot\s+', # Refined regex
                mutation_rules=[
                    {'from': r'\bnot\b', 'to': '', 'type': 'logical', 'description': 'Remove NOT operator'},
                ],
                impact_weight=2.5, # Kept original weight, can be re-evaluated
                description="Mutations removing the NOT operator" # Updated description
            )
        ]
    
    def _calculate_likelihood(self, code_fragment: str, pattern: FaultPattern) -> float:
        """
        Calculates a heuristic likelihood score for a mutant.

        This is a simple heuristic based on characteristics of the
        `code_fragment` (the original code matched by a fault pattern).
        The score is intended to estimate how likely the mutation represents
        a common type of bug.

        Args:
            code_fragment (str): The original code snippet that was matched
                                 by a fault pattern.
            pattern (FaultPattern): The `FaultPattern` object that matched the
                                    code fragment (currently unused in this
                                    method's logic but available for future
                                    enhancements).

        Returns:
            float: A likelihood score, typically between 0.0 and 1.0.
        """
        likelihood = 0.5
        
        if len(code_fragment.split()) > 5:
            likelihood += 0.2
        
        if code_fragment.count('(') > 2:
            likelihood += 0.1
        
        if any(bug_pattern in code_fragment for bug_pattern in ['range', 'len', 'index']):
            likelihood += 0.3
        
        return min(likelihood, 1.0)
    
    def _calculate_cyclomatic_complexity(self, node: ast.AST) -> int:
        """
        Calculates the cyclomatic complexity of a given AST node.

        Complexity is calculated as 1 (for the entry point) + the number of
        decision points (If, While, For, AsyncFor, ExceptHandler, And, Or).
        This is a common measure of code complexity.

        Args:
            node (ast.AST): The AST node (typically a function or module)
                            for which to calculate complexity.

        Returns:
            int: The calculated cyclomatic complexity score.
        """
        complexity = 1
        
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.While, ast.For, ast.AsyncFor)):
                complexity += 1
            elif isinstance(child, ast.ExceptHandler):
                complexity += 1
            elif isinstance(child, (ast.And, ast.Or)):
                complexity += 1
        
        return complexity
    
    # _create_boundary_mutations, _create_numeric_mutations,
    # _create_exception_removal_mutant, _create_exception_type_mutations
    # have been removed as their functionality is now integrated into
    # MutationOperatorVisitor and the refactored _generate_file_mutants.

    def _get_source_files(self) -> List[str]:
        """
        Gets a list of Python source file paths to be processed.

        Currently, this is a placeholder method that returns a single example
        file path based on `self.codebase_path`. In a full implementation,
        this method would scan the `self.codebase_path` directory
        recursively for Python files (e.g., `*.py`).

        Returns:
            List[str]: A list of file paths.
        """
        # Placeholder - would scan directory for Python files
        return [f"{self.codebase_path}/example.py"]

    def generate_mutants_for_project(self, project_path: str, target_mutation_types: Optional[List[MutantType]] = None, max_workers: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Generates raw mutant data for all Python files in a project directory.

        This method traverses the specified `project_path`, reads each Python
        file, and processes them in parallel using `_process_single_file_for_mutants`.
        The `MutationOperatorVisitor` is used within each worker process to
        identify and generate raw mutant data (dictionaries).

        This method is primarily for bulk generation of raw mutant data and
        differs from `generate_smart_mutants` which produces scored and
        prioritized `Mutant` objects.

        Args:
            project_path (str): The root path of the Python project to scan
                                for `.py` files.
            target_mutation_types (Optional[List[MutantType]]): An optional
                list of `MutantType` enums. If provided, only mutants of
                these types will be generated by the underlying visitor in
                each worker process. If None or empty, all implemented
                mutation types are attempted.
            max_workers (Optional[int]): The maximum number of worker processes
                to use for parallel execution. Defaults to `os.cpu_count()`.

        Returns:
            List[Dict[str, Any]]: A list of dictionaries, where each dictionary
            represents raw data for a generated mutant. This data typically
            includes file path, line number, operator information, code snippets,
            and mutation type. Returns an empty list if the `project_path`
            is invalid or no files are processed.
        """
        if target_mutation_types:
            target_type_names = [mt.name for mt in target_mutation_types]
            logger.info(f"Starting mutant generation for project: {project_path}, targeting types: {target_type_names}")
        else:
            logger.info(f"Starting mutant generation for project: {project_path}, targeting all available types.")
        
        all_mutants: List[Dict[str, Any]] = []
        project_path_obj = pathlib.Path(project_path)

        if not project_path_obj.is_dir():
            logger.error(f"Project path {project_path} is not a directory or does not exist.")
            return []

        files_to_process: List[Tuple[str, str]] = []
        for root, _, files in os.walk(project_path_obj):
            for filename in files:
                if filename.endswith(".py"):
                    file_path = pathlib.Path(root) / filename
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            source_code = f.read()
                        files_to_process.append((str(file_path), source_code))
                    except Exception as e:
                        logger.warning(f"Could not read file {file_path}: {e}")
        
        num_workers = max_workers if max_workers is not None else os.cpu_count()
        logger.info(f"Processing {len(files_to_process)} files using up to {num_workers} workers.")

        with ProcessPoolExecutor(max_workers=num_workers) as executor:
            future_to_filepath = {
                executor.submit(
                    _process_single_file_for_mutants,
                    fp_str,
                    content,
                    target_mutation_types
                ): fp_str for fp_str, content in files_to_process
            }

            for future in as_completed(future_to_filepath):
                fp_str = future_to_filepath[future]
                try:
                    file_mutants = future.result()
                    if file_mutants:
                        logger.debug(f"Successfully processed {fp_str}, found {len(file_mutants)} mutants.")
                        all_mutants.extend(file_mutants)
                except Exception as exc:
                    logger.error(f"File {fp_str} generated an exception during parallel processing: {exc}")
        
        logger.info(f"Total mutants generated for project {project_path}: {len(all_mutants)}")
        return all_mutants
